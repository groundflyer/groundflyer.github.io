==================================
Глобалка на пойнт клаудах в Мантре
==================================

:date: 2016-10-22
:modified: 2016-10-23
:category: Houdini
:tags: mantra, vex
:slug: point-based-gi
:lang: ru
:status: published
:summary:
   Этот лайт шейдер я написал когда-то ради эксперимента, но он оказался довольно неплох. В этой статье я кратко опишу его принципы.
:cover: images/pbgi.jpg
:og_locale: ru_RU

Метод, который я опишу здесь, на первый взгляд очень похож на старый устаревший рендермановский метод просчета глобального освещения [@Christensen10].
Однако, это лишь внешнее сходство - Renderman использует облака точек не только для хранения кэша, но и непосредственно для просчета освещенности.

Шейдер лайта
============

Алгоритм нашего шейдера предельно прост:

* проход запекания:

  1. считаем глобалку в текущей точке

  2. записываем полученное значение вместе с позицией и нормалью в облако точек

* финальный проход:

  1. считываем несколько ближайших точек

  2. усредняем (фильтруем)


Создание шейдера лайта
	В главном меню File -> New Operator Type...
	Выбираем Operator Style - VEX Type, Network Type - Light Shader Operator,
	указываем куда сохранить и вводим названия в соответствующие поля.

	Теперь во вкладке Code мы можем писать свой код, используя `контекст лайта`__.

__ http://www.sidefx.com/docs/houdini15.5/vex/contexts/light

Глобальное освещение вычисляем с помощью функции `irradiance()`_.
Далее записываем полученное значение в облако точек с помощью `pcwrite()`_:

.. code-block:: c
   :linenos: inline

   vector n = normalize(N);

   vector Cd = irradiance(Ps, n,
		"samples", samples,
		"environment", envmap,
		"envlight", space);

   vector wP = ptransform("space:world", Ps);
   vector wN = ntransform("space:world", n);

   if (!(getraylevel() + getglobalraylevel()))
	pcwrite(pcfile, "P", wP, "N", wN, "Cd", Cd);

Здесь мы преобразуем позицию и нормаль в из пространства камеры в пространство мира. Вообще, можно обойтись без этого, но только в случае, если мы будем запекать и рендерить одной и той же камерой.

В 11-ой строке производится проверка, что мы используем primary ray, т.е. на нулевой глубине. В противном случае точки могут быть записаны из ненужных нам мест при вызове какой-нибудь рекурсивной функции типа gather().

Чтение и сглаживание в финальном проходе осуществляется с помощью `pcopen()`_ и `pcfilter()`_:

.. code-block:: c

   int handle = pcopen(pcfile, "P", wP, radius, maxpoints, "preload", 1);
   Cl = pcfilter(handle, "Cd");
   pcclose(handle);

Исходный код лайта, который должен получиться в конце:

[gist:id=5be8cf68d58838f7b9ce91164c7d41c4]

Настройка сцены
===============

Чтобы воспользоваться шейдером, нужно создать Template Light и указать в нём Light Shader.

Так как нужно два прохода, создаем две ROPы: одну для запекания, вторую для финального рендера.

Для прохода запекания я обычно создаю новый Take и меняю в нём параметр Mode лайта на Write.
Затем в bake ROPе я указываю этот тейк.
Запекаем только в микрополигональном режиме, т.к. нам крайне желательна регулярная сетка.
Нам не нужна картинка из прохода запекания, так что я выставляю Output Image в /dev/null - это для Linux,
на Windows это должно быть NUL.

Бьюти пасс можно рендерить уже любым движком.

Сохраненное облако точек, кстати, открывается с помощью File SOP. Примерно такой должен получиться результат.

.. vimeo:: 187550386
   :width: 800
   :height: 450
   :align: center

Оптимизации
===========

На ROPе bake-прохода также лучше отключить hiding, а во вкладке Dicing параметер Geometry Measuring установить в Uniform Measuring. Чтобы уменьшить/увеличить плотность точек можно покрутить Shading Quality Multiplier как на ROPе, так и на объектах.

Чтобы запекать глобалку с более глубоким диффузным отскоком, нужно сделать шейдер хитрее. Используйте для этого `getglobalraylevel()`_ чтобы узнать текущую глубину и `renderstate()`_ чтобы узнать Diffuse Limit.

`pcfilter()`_ усредняет значение точек, взвешивая их только по расстоянию. Я, например, использую свою функцию для фильтрации, которая также принимает во внимание нормаль:

.. math::

   C = \frac{\sum_{i=0}^N C_i}{\sum_{i=0}^N \left(\frac{\cos \theta_i}{r_i}\right)^2}

, где :math:`C` - результат фильтрации, :math:`N` - количество точек, :math:`C_i` -  цвет, сохранённый в :math:`i`-той точке, :math:`\theta_i` - угол между нормалью поверхности и нормалью :math:`i`-той точки, а :math:`r` - расстояние до неё.

Все вычисления описанные выше возможно делать только в одном проходе.
Для этого нужно сгенерировать облако точек "на лету", используя `pcgenerate()`_, а затем пробежаться по ним с помощью итератора `pcunshaded()`_, задать позицию и нормаль с помощью `sample_geometry()`_ и уже затем высчитать в точке освещенность. Сглаживание полученных значений остается неизменным.
Такой лайт правда будет всегда фликерить.
Мантровский SSS на точках как раз сделан подобным способом.

Недостатки метода
=================

По сравнению с современной трассировкой путей у этого метода есть серьезные недостатки:

1. костыльность
  
2. делается в два прохода
  
3. лишняя запись-чтение с диска
  
4. учитывает только диффузные отражения
  
5. потенциальный фликеринг
  
6. полное игнорирование BSDF
  
7. сложная и не гибкая настройка
  
8. одна точка - одно значение, с двухсторонними материалами будет отсос

.. _irradiance(): http://www.sidefx.com/docs/houdini15.5/vex/functions/irradiance
.. _pcwrite(): http://www.sidefx.com/docs/houdini15.5/vex/functions/pcwrite
.. _pcopen(): http://www.sidefx.com/docs/houdini15.5/vex/functions/pcopen
.. _pcfilter(): http://www.sidefx.com/docs/houdini15.5/vex/functions/pcfilter
.. _getglobalraylevel(): http://www.sidefx.com/docs/houdini15.5/vex/functions/getglobalraylevel
.. _renderstate(): http://www.sidefx.com/docs/houdini15.5/vex/functions/renderstate
.. _pcunshaded(): http://www.sidefx.com/docs/houdini15.5/vex/functions/pcunshaded
.. _sample_geometry(): http://www.sidefx.com/docs/houdini15.5/vex/functions/sample_geometry
.. _pcgenerate(): http://www.sidefx.com/docs/houdini15.5/vex/functions/pcgenerate
